<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–ü—Ä–æ—Å—Ç–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è ‚Äî –§–∏–≥—É—Ä—ã –∏ –ø–µ—Ä–∏–º–µ—Ç—Ä (2 –∫–ª–∞—Å—Å)</title>
  <meta name="description" content="–£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ: —É–∑–Ω–∞–≤–∞—Ç—å —Ñ–∏–≥—É—Ä—ã –∏ —Å—á–∏—Ç–∞—Ç—å –ø–µ—Ä–∏–º–µ—Ç—Ä –ø—Ä–æ—Å—Ç—ã—Ö —Ñ–∏–≥—É—Ä (–ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫). –î–ª—è 2 –∫–ª–∞—Å—Å–∞.">
  <style>
    :root{
      --bg:#f6fbff; --card:#fff; --accent:#2b8cff; --muted:#6b7280;
      --ok:#2aa653; --err:#e03d3d; --btn:#4CAF50;
    }
    *{box-sizing:border-box}
    body{margin:0;padding:14px;font-family:Inter,Segoe UI,Arial,Helvetica,sans-serif;background:var(--bg);color:#071029}
    a.home-btn{display:inline-block;margin:10px 0;padding:10px 14px;font-size:16px;background:var(--btn);color:white;border-radius:8px;text-decoration:none}
    header{display:flex;gap:12px;align-items:center;max-width:980px;margin:0 auto 12px}
    .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7cc4ff);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}
    h1{font-size:1.15rem;margin:0}
    .meta{color:var(--muted);font-size:0.92rem}
    main{max-width:980px;margin:0 auto;background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 20px rgba(15,23,42,0.06)}
    .controls{display:flex;flex-direction:column;gap:8px;margin-bottom:10px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    select,input,button{padding:10px;border-radius:10px;border:1px solid #dbeafe;background:white}
    label{font-size:0.95rem}
    .panel{padding:12px;border-radius:10px;background:linear-gradient(180deg,#fff,#fbfdff);border:1px solid #eef6ff}
    .task{font-weight:800;font-size:1.2rem;text-align:center;margin:6px 0}
    .viz{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:12px;flex-wrap:wrap}
    .shape-card{width:180px;max-width:45%;background:#fff;border-radius:10px;padding:10px;border:1px solid #e6f0ff;text-align:center}
    svg{max-width:100%;height:auto}
    .options{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:10px}
    .option-btn{padding:10px 12px;border-radius:8px;border:1px solid #dbeafe;background:white;cursor:pointer}
    .option-btn.selected{outline:3px solid rgba(43,140,255,0.12)}
    .answer-row{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:12px}
    .answer-row input{width:120px;text-align:center}
    .hint{margin-top:10px;color:var(--muted);text-align:center}
    .feedback{min-height:44px;text-align:center;font-weight:700;margin-top:8px}
    .feedback.ok{color:var(--ok)} .feedback.err{color:var(--err)}
    @media(min-width:880px){ .controls{flex-direction:row} .shape-card{max-width:180px} }
  </style>
</head>
<body>
  <a href="index.html" class="home-btn">üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é</a>

  <header>
    <div class="logo">M2</div>
    <div>
      <h1>–§–∏–≥—É—Ä—ã –∏ –ø–µ—Ä–∏–º–µ—Ç—Ä</h1>
      <div class="meta">–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä –∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–µ—Ä–∏–º–µ—Ç—Ä–∞ (—Å–º). –ü–µ—Ä–∏–º–µ—Ç—Ä = —Å—É–º–º–∞ —Å—Ç–æ—Ä–æ–Ω.</div>
    </div>
  </header>

  <main>
    <div class="controls" role="region" aria-label="–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ">
      <div class="row">
        <label for="level">–£—Ä–æ–≤–µ–Ω—å</label>
        <select id="level" aria-label="–£—Ä–æ–≤–µ–Ω—å">
          <option value="1">1 ‚Äî –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã (–∫–≤–∞–¥—Ä–∞—Ç/–ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫/—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫)</option>
          <option value="2">2 ‚Äî –ü–µ—Ä–∏–º–µ—Ç—Ä –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ (–≤ —Å–º, —Ü–µ–ª—ã–µ)</option>
        </select>

        <label for="seriesCount" style="margin-left:6px">–°–µ—Ä–∏—è ‚Äî –ø—Ä–∏–º–µ—Ä–æ–≤</label>
        <input id="seriesCount" type="number" min="1" max="50" value="8" style="width:96px">

        <div style="margin-left:auto;color:var(--muted)">–õ—É—á—à–∏–π: <span id="best">‚Äî</span></div>
      </div>

      <div class="row">
        <input id="student" placeholder="–ò–º—è —É—á–µ–Ω–∏–∫–∞ (–ª–æ–∫–∞–ª—å–Ω–æ)" style="flex:1">
        <div style="margin-left:auto;color:var(--muted)">–ü—Ä–æ–≥—Ä–µ—Å—Å: <span id="progress">0/8</span></div>
      </div>
    </div>

    <section class="panel" aria-labelledby="taskHeading">
      <div class="task" id="taskText">‚Äî</div>

      <div class="viz" id="vizArea" aria-live="polite">
        <!-- shape card injected here -->
      </div>

      <!-- Level 1 choices -->
      <div class="options" id="choicesArea" style="display:none" role="radiogroup" aria-label="–í–∞—Ä–∏–∞–Ω—Ç—ã —Ñ–∏–≥—É—Ä">
        <!-- buttons injected -->
      </div>

      <!-- Level 2 answer input -->
      <div class="answer-row" id="perimeterRow" style="display:none">
        <label>–ü–µ—Ä–∏–º–µ—Ç—Ä (—Å–º): <input id="answerInput" type="number" min="1" inputmode="numeric" aria-label="–ü–µ—Ä–∏–º–µ—Ç—Ä –≤ —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–∞—Ö"></label>
      </div>

      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="checkBtn">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="showBtn">–ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–≤–µ—Ç</button>
        <button id="skipBtn">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
      </div>

      <div id="feedback" class="feedback" role="status" aria-live="polite">&nbsp;</div>

      <div class="hint" id="hintBox">–ü–æ–¥—Å–∫–∞–∑–∫–∞: –ø–µ—Ä–∏–º–µ—Ç—Ä ‚Äî —ç—Ç–æ —Å—É–º–º–∞ –¥–ª–∏–Ω –≤—Å–µ—Ö —Å—Ç–æ—Ä–æ–Ω. –í—Å–µ —á–∏—Å–ª–∞ ‚Äî –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ (—Ü–µ–ª—ã–µ —Å–∞–Ω–∏–º–µ—Ç—Ä—ã).</div>
    </section>
  </main>

<script>
(function(){
  // DOM
  const levelEl = document.getElementById('level');
  const seriesCountEl = document.getElementById('seriesCount');
  const studentEl = document.getElementById('student');
  const taskText = document.getElementById('taskText');
  const vizArea = document.getElementById('vizArea');
  const choicesArea = document.getElementById('choicesArea');
  const perimeterRow = document.getElementById('perimeterRow');
  const answerInput = document.getElementById('answerInput');
  const checkBtn = document.getElementById('checkBtn');
  const showBtn = document.getElementById('showBtn');
  const skipBtn = document.getElementById('skipBtn');
  const feedback = document.getElementById('feedback');
  const hintBox = document.getElementById('hintBox');
  const progressEl = document.getElementById('progress');
  const bestEl = document.getElementById('best');

  // state
  let seriesTotal = Math.max(1, parseInt(seriesCountEl.value||'8',10));
  let seriesCurrent = 0;
  let current = null; // object describing current task
  const shapes = ['–ö–≤–∞–¥—Ä–∞—Ç','–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫','–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫'];
  let best = parseInt(localStorage.getItem('geom_best')||'0',10) || 0;
  bestEl.textContent = best>0? (best + '‚òÖ') : '‚Äî';

  // helpers
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function updateProgress(){ seriesTotal = Math.max(1, parseInt(seriesCountEl.value||'8',10)); progressEl.textContent = `${seriesCurrent}/${seriesTotal}`; }

  // generators
  function genRecognition(){
    // choose randomly one of three shapes, but ensure natural presentation
    const idx = randInt(0, shapes.length-1);
    const shape = shapes[idx];
    // For recognition, also prepare a simple SVG representation
    return { kind:'recognize', shape };
  }

  function genRectanglePerimeter(){
    // produce width and height as natural integers (cm), ensure >=1 and not equal optional
    const w = randInt(2,20); // width in cm
    const h = randInt(1,20);  // height in cm
    // ensure reasonable variety; allow square as special case (still rectangle)
    return { kind:'perimeter-rect', w, h, answer: 2*(w + h) };
  }

  function renderTask(t){
    vizArea.innerHTML = '';
    choicesArea.style.display = 'none';
    perimeterRow.style.display = 'none';
    answerInput.value = '';
    feedback.textContent = '';
    if(t.kind === 'recognize'){
      taskText.textContent = '–ö–∞–∫–∞—è —ç—Ç–æ —Ñ–∏–≥—É—Ä–∞?';
      // render one of three SVGs (simplified)
      const card = document.createElement('div'); card.className='shape-card';
      card.innerHTML = renderShapeSVG(t.shape) + `<div style="margin-top:8px;font-weight:700">${t.shape}</div>`;
      vizArea.appendChild(card);
      // show choices
      choicesArea.style.display = '';
      choicesArea.innerHTML = '';
      shapes.forEach(name => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'option-btn';
        btn.textContent = name;
        btn.dataset.name = name;
        btn.addEventListener('click', ()=> {
          // toggle selection
          Array.from(choicesArea.children).forEach(n=>n.classList.remove('selected'));
          btn.classList.add('selected');
          current._selected = name;
        });
        choicesArea.appendChild(btn);
      });
    } else if(t.kind === 'perimeter-rect'){
      taskText.textContent = '–ù–∞–π–¥–∏—Ç–µ –ø–µ—Ä–∏–º–µ—Ç—Ä –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ (–≤ —Å–º)';
      // render rectangle svg with labeled sides
      const card = document.createElement('div'); card.className='shape-card';
      card.innerHTML = renderRectangleSVG(t.w, t.h) + `<div style="margin-top:8px;color:var(--muted)">–®–∏—Ä–∏–Ω–∞: ${t.w} —Å–º ¬∑ –í—ã—Å–æ—Ç–∞: ${t.h} —Å–º</div>`;
      vizArea.appendChild(card);
      // show input
      perimeterRow.style.display = '';
      answerInput.focus();
    }
    updateProgress();
  }

  function renderShapeSVG(name){
    // simple consistent SVG for each
    if(name === '–ö–≤–∞–¥—Ä–∞—Ç'){
      return `<svg width="140" height="100" viewBox="0 0 140 100" xmlns="http://www.w3.org/2000/svg"><rect x="18" y="12" width="100" height="100" transform="translate(0,-12)" fill="#ffd08a" stroke="#ffb36b" stroke-width="3" rx="6"/></svg>`;
    }
    if(name === '–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫'){
      return `<svg width="140" height="100" viewBox="0 0 140 100" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="22" width="120" height="60" fill="#9fe6a0" stroke="#7fd188" stroke-width="3" rx="6"/></svg>`;
    }
    // triangle
    return `<svg width="140" height="100" viewBox="0 0 140 100" xmlns="http://www.w3.org/2000/svg"><polygon points="70,12 130,86 10,86" fill="#a8d2ff" stroke="#7fb9ff" stroke-width="3"/></svg>`;
  }

  // ---------- Fixed renderRectangleSVG: corrected viewBox/margins so labels always visible ----------
  function renderRectangleSVG(w,h){
    // scale for display: map cm to px proportionally but constrain
    // We'll compute px sizes but always leave margins for labels
    const pxPerCm = 3; // base scale
    const sw = Math.max(60, Math.round(w * pxPerCm));
    const sh = Math.max(40, Math.round(h * pxPerCm));

    // margins to ensure text fits
    const marginLeft = 40;
    const marginTop = 30;
    const marginRight = 40;
    const marginBottom = 40;

    const viewW = sw + marginLeft + marginRight;
    const viewH = sh + marginTop + marginBottom;

    const rectX = marginLeft;
    const rectY = marginTop;

    // bottom label position
    const bottomX = rectX + sw / 2;
    const bottomY = rectY + sh + 24; // below the rectangle, inside the viewBox

    // left (vertical) label position and rotation center
    const leftX = rectX - 14; // place to the left inside the margin
    const leftY = rectY + sh / 2;

    const svg = `<svg width="${Math.min(420, viewW)}" height="${Math.min(260, viewH)}" viewBox="0 0 ${viewW} ${viewH}" xmlns="http://www.w3.org/2000/svg">
      <rect x="${rectX}" y="${rectY}" width="${sw}" height="${sh}" fill="#fff7e6" stroke="#ffb36b" stroke-width="3" rx="6"/>
      <!-- bottom (width) label -->
      <text x="${bottomX}" y="${bottomY}" text-anchor="middle" font-size="12" fill="#16325c">${w} —Å–º</text>
      <!-- left (height) label rotated -->
      <text x="${leftX}" y="${leftY}" transform="rotate(-90 ${leftX} ${leftY})" text-anchor="middle" font-size="12" fill="#16325c">${h} —Å–º</text>
    </svg>`;
    return svg;
  }
  // ----------------------------------------------------------------------------------------------

  // create task depending on level
  function genTask(){
    const level = levelEl.value;
    if(level === '1'){
      current = genRecognition();
    } else {
      // level 2
      current = genRectanglePerimeter();
    }
    renderTask(current);
  }

  function genRecognition(){
    const idx = randInt(0, shapes.length-1);
    const shape = shapes[idx];
    return { kind:'recognize', shape };
  }
  function genRectanglePerimeter(){
    const w = randInt(2,20);
    const h = randInt(1,20);
    return { kind:'perimeter-rect', w, h, answer: 2*(w + h) };
  }

  function checkAnswer(){
    if(!current) return;
    if(current.kind === 'recognize'){
      const sel = current._selected || null;
      if(!sel){ feedback.className='feedback err'; feedback.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç.'; return; }
      if(sel === current.shape){
        onCorrect();
      } else {
        onWrong(`–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${current.shape}.`);
      }
    } else if(current.kind === 'perimeter-rect'){
      const valRaw = answerInput.value.trim();
      const val = valRaw === '' ? NaN : parseInt(valRaw,10);
      if(Number.isNaN(val) || val < 1){ feedback.className='feedback err'; feedback.textContent = '–í–≤–µ–¥–∏—Ç–µ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ (—Å–º).'; return; }
      if(val === current.answer){
        onCorrect();
      } else {
        onWrong(`–û–∂–∏–¥–∞–ª–æ—Å—å ${current.answer} —Å–º.`);
      }
    }
  }

  function onCorrect(){
    feedback.className='feedback ok'; feedback.textContent = '–ü—Ä–∞–≤–∏–ª—å–Ω–æ!';
    saveResult(true);
    seriesCurrent += 1;
    updateProgress();
    if(seriesCurrent >= seriesTotal){
      setTimeout(endSeries, 600);
    } else {
      setTimeout(()=>genTask(), 700);
    }
  }

  function onWrong(msg){
    feedback.className='feedback err'; feedback.textContent = msg;
    saveResult(false);
  }

  function showAnswer(){
    if(!current) return;
    if(current.kind === 'recognize'){
      feedback.className=''; feedback.textContent = `–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ñ–∏–≥—É—Ä–∞: ${current.shape}.`;
      Array.from(choicesArea.children).forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.name === current.shape);
      });
      current._selected = current.shape;
    } else {
      feedback.className=''; feedback.textContent = `–ü–µ—Ä–∏–º–µ—Ç—Ä: ${current.answer} —Å–º.`;
      answerInput.value = String(current.answer);
    }
  }

  function skipTask(){
    saveResult(false);
    seriesCurrent += 1;
    updateProgress();
    if(seriesCurrent >= seriesTotal) endSeries();
    else genTask();
  }

  function endSeries(){
    feedback.className=''; feedback.textContent = `–°–µ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: ${seriesCurrent}/${seriesTotal}.`;
    seriesCurrent = 0;
    updateProgress();
  }

  // scoring: store streak of consecutive correct answers as 'best'
  function saveResult(ok){
    let cur = parseInt(localStorage.getItem('geom_cur')||'0',10) || 0;
    let bestNow = parseInt(localStorage.getItem('geom_best')||'0',10) || 0;
    if(ok){ cur += 1; if(cur > bestNow){ bestNow = cur; localStorage.setItem('geom_best', String(bestNow)); } }
    else { cur = 0; }
    localStorage.setItem('geom_cur', String(cur));
    localStorage.setItem('geom_best', String(bestNow));
    bestEl.textContent = bestNow>0? (bestNow + '‚òÖ') : '‚Äî';
  }

  // events
  checkBtn.addEventListener('click', checkAnswer);
  showBtn.addEventListener('click', showAnswer);
  skipBtn.addEventListener('click', skipTask);
  levelEl.addEventListener('change', ()=>{ genTask(); });
  seriesCountEl.addEventListener('change', ()=>{ updateProgress(); });
  document.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') checkAnswer(); });

  // init
  updateProgress();
  genTask();

})();
</script>
</body>
</html>
