<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–µ–Ω–∏—è –∏ –≤—ã—á–∏—Ç–∞–Ω–∏—è ‚Äî –¢—Ä–µ–Ω–∞–∂—ë—Ä</title>
  <meta name="description" content="–¢—Ä–µ–Ω–∞–∂—ë—Ä: —Ç–∞–±–ª–∏—Ü–∞ –ø—Ä–∏–º–µ—Ä–æ–≤ (3√ó3/5√ó5/10√ó10). –†–µ–∂–∏–º—ã: –Ω–∞ –≤—Ä–µ–º—è / –±–µ–∑ –≤—Ä–µ–º–µ–Ω–∏. –ë–∞–ª–ª—ã = —Ç–æ—á–Ω–æ—Å—Ç—å + —Å–∫–æ—Ä–æ—Å—Ç—å ‚Üí –º–µ–¥–∞–ª–∏.">
  <style>
    :root{
      --bg:#f6fbff; --card:#fff; --accent:#2b8cff; --muted:#6b7280;
      --ok:#2aa653; --bad:#e03d3d; --cell:#f8fbff;
      --btn-bg:#fff; --btn-border:#dbeafe;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;padding:12px;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#071029}
    .home-btn{display:inline-block;margin:8px 0;padding:10px 14px;font-size:15px;background-color:#4CAF50;color:white;border-radius:8px;text-decoration:none}
    header{display:flex;gap:12px;align-items:center;max-width:1100px;margin:6px auto 12px}
    .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7cc4ff);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700}
    h1{font-size:1.05rem;margin:0}
    .meta{color:var(--muted);font-size:0.9rem}
    main{max-width:1100px;margin:0 auto;background:var(--card);padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(15,23,42,0.06)}
    .top-controls{display:flex;flex-direction:column;gap:8px;padding:8px}
    .row{display:flex;gap:8px;align-items:center}
    select,input[type="number"],button{padding:10px;border-radius:10px;border:1px solid var(--btn-border);background:var(--btn-bg);font-size:0.98rem}
    .spacer{flex:1}
    .grid-wrap{padding:10px}
    .grid{display:grid;gap:8px;justify-items:stretch;align-items:stretch}
    .cell{background:var(--cell);border-radius:8px;padding:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;min-width:64px;min-height:70px}
    .expr{font-weight:800;font-size:1.05rem;margin-bottom:8px}
    .cell input{width:72px;padding:8px;border-radius:8px;border:1px solid #dbeafe;text-align:center;font-weight:700}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:10px}
    .small{font-size:0.9rem;padding:8px 10px}
    .status{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:12px}
    .stat{padding:8px;border-radius:8px;background:#fbfdff;border:1px solid #eef6ff}
    .feedback{margin-top:12px;font-weight:700;text-align:center;min-height:36px}
    .feedback.ok{color:var(--ok)} .feedback.bad{color:var(--bad)}
    .legend{margin-top:12px;color:var(--muted);font-size:0.92rem}
    input.revealed{background:#fff7e6}
    @media(min-width:880px){ .top-controls{flex-direction:row;align-items:center} .grid{ } }
  </style>
</head>
<body>
  <a href="index.html" class="home-btn">üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é</a>

  <header>
    <div class="logo">M2</div>
    <div>
      <h1>–¢–∞–±–ª–∏—Ü–∞ —Å–ª–æ–∂–µ–Ω–∏—è –∏ –≤—ã—á–∏—Ç–∞–Ω–∏—è</h1>
      <div class="meta">–¢—Ä–µ–Ω–∏—Ä—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏–∑–º ‚Äî —Å–∫–æ—Ä–æ—Å—Ç—å –∏ —Ç–æ—á–Ω–æ—Å—Ç—å</div>
    </div>
  </header>

  <main>
    <div class="top-controls">
      <div class="row">
        <label for="level">–£—Ä–æ–≤–µ–Ω—å:</label>
        <select id="level" aria-label="–£—Ä–æ–≤–µ–Ω—å">
          <option value="1">1 ‚Äî —Å–ª–æ–∂–µ–Ω–∏–µ –¥–æ 10 (–±–µ–∑ –ø–µ—Ä–µ—Ö–æ–¥–∞)</option>
          <option value="2">2 ‚Äî –≤—ã—á–∏—Ç–∞–Ω–∏–µ –¥–æ 10</option>
          <option value="3">3 ‚Äî —Å–ª–æ–∂–µ–Ω–∏–µ/–≤—ã—á–∏—Ç–∞–Ω–∏–µ –¥–æ 20 (—Å –ø–µ—Ä–µ—Ö–æ–¥–æ–º)</option>
          <option value="4">4 ‚Äî —Å–º–µ—à–∞–Ω–Ω—ã–µ –¥–æ 100</option>
        </select>

        <label for="size">–†–∞–∑–º–µ—Ä:</label>
        <select id="size" aria-label="–†–∞–∑–º–µ—Ä">
          <option value="3">3 √ó 3</option>
          <option value="5">5 √ó 5</option>
          <option value="10">10 √ó 10</option>
        </select>

        <label><input type="checkbox" id="timed"> –†–µ–∂–∏–º ¬´–Ω–∞ –≤—Ä–µ–º—è¬ª</label>

        <label for="timeLimit" style="margin-left:6px">–õ–∏–º–∏—Ç (—Å):</label>
        <input id="timeLimit" type="number" min="10" max="3600" value="120" style="width:96px">

        <div class="spacer"></div>

        <button id="startBtn" class="small">–ù–∞—á–∞—Ç—å</button>
        <button id="checkBtn" class="small">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—Å—ë</button>
        <button id="resetBtn" class="small">–°–±—Ä–æ—Å</button>
      </div>

      <div class="row">
        <div class="toolbar" style="width:100%;justify-content:flex-start;">
          <!-- –†–µ–∂–∏–º —É–±—Ä–∞–Ω (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –ø–æ —É—Ä–æ–≤–Ω—é) -->
          <label>–ü–æ–∫–∞–∑/—Å–∫—Ä—ã—Ç—å –æ—Ç–≤–µ—Ç—ã: <button id="revealBtn" class="small">–ü–æ–∫–∞–∑–∞—Ç—å</button></label>
          <div style="margin-left:8px" class="legend">–ö–ª–∞–≤–∏—à–∏: Enter ‚Äî –ø–µ—Ä–µ–π—Ç–∏/–ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å—Ç—Ä–µ–ª–∫–∏ ‚Äî –Ω–∞–≤–∏–≥–∞—Ü–∏—è</div>
        </div>
      </div>
    </div>

    <div class="grid-wrap">
      <div id="metaStatus" class="status" aria-live="polite">
        <div class="stat">–í—Ä–µ–º—è: <span id="time">0</span> —Å</div>
        <div class="stat">–ü—Ä–∞–≤–∏–ª—å–Ω–æ: <span id="correct">0</span></div>
        <div class="stat">–í—Å–µ–≥–æ: <span id="total">0</span></div>
        <div class="stat">–ë–∞–ª–ª—ã: <span id="score">0</span></div>
        <div class="stat">–ú–µ–¥–∞–ª—å: <strong id="medal">‚Äî</strong></div>
      </div>

      <div id="board" style="margin-top:12px"></div>

      <div id="afterArea" style="margin-top:12px">
        <div id="finalMsg" class="feedback" aria-live="polite"></div>
      </div>
    </div>
  </main>

<script>
(function(){
  // Helpers
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }
  // DOM
  const levelEl = document.getElementById('level');
  const sizeEl = document.getElementById('size');
  const timedEl = document.getElementById('timed');
  const timeLimitEl = document.getElementById('timeLimit');
  const startBtn = document.getElementById('startBtn');
  const checkBtn = document.getElementById('checkBtn');
  const resetBtn = document.getElementById('resetBtn');
  const revealBtn = document.getElementById('revealBtn');

  const boardEl = document.getElementById('board');
  const timeEl = document.getElementById('time');
  const correctEl = document.getElementById('correct');
  const totalEl = document.getElementById('total');
  const scoreEl = document.getElementById('score');
  const medalEl = document.getElementById('medal');
  const finalMsg = document.getElementById('finalMsg');

  // State
  let grid = []; // {expr, ans, inputEl, status}
  let rows=3, cols=3;
  let running=false;
  let timerId=null; let startTs=0;
  let seconds=0;
  let reveal=false;

  // For reveal/hide: remember which indices we auto-filled and original user values
  let autoRevealed = new Set();
  let originalValues = {};

  // Determine mode automatically from level:
  // level 1 -> add, 2 -> sub, 3,4 -> mixed
  function modeForLevel(level){
    if(level === 1) return 'add';
    if(level === 2) return 'sub';
    return 'mixed';
  }

  // Generation rules: produce natural numbers and no negative/zero results
  function genProblem(level, mode){
    // level: 1..4
    // mode: 'mixed','add','sub'
    // ensure natural numbers results (>=1)

    if(level === 1){
      // addition only, sum <= 10, no carry: choose a,b >=1 such that a+b <=10
      const a = randInt(1,9); const b = randInt(1, 10 - a);
      return {op:'+', a:a, b:b, ans: a + b};
    }

    if(level === 2){
      // new level: subtraction up to 10 (result >=1)
      // choose a between 2..10, b between 1..a-1
      const a = randInt(2,10);
      const b = randInt(1, a-1);
      return {op:'-', a:a, b:b, ans: a - b};
    }

    if(level === 3){
      // addition or subtraction up to 20; if addition ensure sum<=20; if subtraction ensure a>b
      if(mode === 'add' || (mode==='mixed' && Math.random()<0.6)){
        const a = randInt(1,19);
        const b = randInt(1, Math.max(1, 20 - a));
        return {op:'+', a:a, b:b, ans:a+b};
      } else {
        // subtraction
        const a = randInt(2,20);
        const b = randInt(1, a-1); // ensure result >=1
        return {op:'-', a:a, b:b, ans:a-b};
      }
    }

    // level 4: mixed up to 100
    if(level === 4){
      if(mode === 'add' || (mode==='mixed' && Math.random()<0.5)){
        const a = randInt(1,99);
        const b = randInt(1, Math.max(1, 100 - a));
        return {op:'+', a:a, b:b, ans:a+b};
      } else {
        const a = randInt(2,100);
        const b = randInt(1,a-1);
        return {op:'-', a:a, b:b, ans:a-b};
      }
    }

    // fallback
    return {op:'+', a:1,b:1,ans:2};
  }

  function buildGrid(){
    // clear any previous auto-reveal state
    autoRevealed.clear();
    originalValues = {};

    boardEl.innerHTML = '';
    rows = parseInt(sizeEl.value,10);
    cols = rows;
    const level = Number(levelEl.value);
    const mode = modeForLevel(level);

    grid = [];
    const container = document.createElement('div');
    container.className = 'grid';
    container.style.gridTemplateColumns = `repeat(${cols}, minmax(64px,1fr))`;

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const p = genProblem(level, mode);
        const cell = document.createElement('div');
        cell.className = 'cell';
        const expr = document.createElement('div');
        expr.className = 'expr';
        expr.textContent = `${p.a} ${p.op} ${p.b}`;
        const inp = document.createElement('input');
        inp.type = 'number';
        inp.inputMode = 'numeric';
        inp.dataset.idx = grid.length;
        inp.placeholder = '';
        inp.autocomplete = 'off';
        inp.addEventListener('keydown', onCellKeyDown);
        inp.addEventListener('focus', ()=>{ if(!running) startTimer(); });
        cell.appendChild(expr);
        cell.appendChild(inp);
        container.appendChild(cell);

        grid.push({exprText: `${p.a} ${p.op} ${p.b}`, a:p.a, b:p.b, op:p.op, ans:p.ans, inputEl: inp, cellEl: cell, status: 'idle' });
      }
    }

    boardEl.appendChild(container);
    totalEl.textContent = String(grid.length);
    correctEl.textContent = '0';
    scoreEl.textContent = '0';
    medalEl.textContent = '‚Äî';
    finalMsg.textContent = '';
    // focus first input
    setTimeout(()=>{ if(grid[0] && grid[0].inputEl) grid[0].inputEl.focus(); }, 50);
  }

  // Keyboard navigation & actions within cells
  function onCellKeyDown(e){
    const idx = Number(this.dataset.idx);
    if(e.key === 'Enter'){
      // move to next cell or check if last
      e.preventDefault();
      const next = idx + 1;
      if(grid[next]) grid[next].inputEl.focus();
      else { /* last cell */ }
    } else if(e.key === 'ArrowRight'){
      e.preventDefault(); const next = Math.min(grid.length-1, idx+1); grid[next].inputEl.focus();
    } else if(e.key === 'ArrowLeft'){
      e.preventDefault(); const prev = Math.max(0, idx-1); grid[prev].inputEl.focus();
    } else if(e.key === 'ArrowDown'){
      e.preventDefault(); const down = idx + cols; if(grid[down]) grid[down].inputEl.focus();
    } else if(e.key === 'ArrowUp'){
      e.preventDefault(); const up = idx - cols; if(grid[up]) grid[up].inputEl.focus();
    }
  }

  function startTimer(){
    if(running) return;
    running = true;
    startTs = Date.now();
    seconds = 0;
    timeEl.textContent = '0';
    if(timedEl.checked){
      // set countdown until timeLimit
      const limit = clamp(parseInt(timeLimitEl.value||'120',10),10,3600);
      timerId = setInterval(()=>{
        seconds = Math.floor((Date.now() - startTs)/1000);
        timeEl.textContent = String(seconds);
        if(seconds >= limit){
          clearInterval(timerId); timerId = null;
          finishRun();
        }
      }, 250);
    } else {
      timerId = setInterval(()=>{
        seconds = Math.floor((Date.now() - startTs)/1000);
        timeEl.textContent = String(seconds);
      }, 500);
    }
  }

  function stopTimer(){
    if(timerId) { clearInterval(timerId); timerId = null; }
    running = false;
  }

  function resetAll(){
    stopTimer();
    buildGrid();
  }

  function checkAll(){
    // validate inputs and mark cells
    let correct = 0;
    grid.forEach((g, idx)=>{
      const valRaw = g.inputEl.value.trim();
      const val = valRaw === '' ? NaN : parseInt(valRaw,10);
      const ok = (!Number.isNaN(val)) && (val === g.ans);
      g.status = ok ? 'ok' : 'wrong';
      // visual
      g.cellEl.style.outline = 'none';
      if(ok){
        g.cellEl.style.boxShadow = '0 0 0 3px rgba(42,166,83,0.09)'; // green hint
        g.cellEl.style.border = '1px solid rgba(42,166,83,0.25)';
        correct++;
      } else {
        g.cellEl.style.boxShadow = '0 0 0 3px rgba(224,61,61,0.06)';
        g.cellEl.style.border = '1px solid rgba(224,61,61,0.18)';
      }
    });
    correctEl.textContent = String(correct);
    // score: base points per correct, time bonus if timed
    const total = grid.length;
    const basePoints = correct * 10;
    let timeBonus = 0;
    if(seconds > 0){
      // faster => bigger bonus. targetTime proportional to cells: e.g., 3s per cell
      const target = total * 3;
      // if finished under target, full bonus, else scaled down; clamp >=0
      timeBonus = Math.max(0, Math.round((Math.max(0,(target - seconds)) / target) * 50));
    }
    const score = basePoints + timeBonus;
    scoreEl.textContent = String(score);
    // medal thresholds (tuned empirically)
    const accuracy = total ? (correct/total) : 0;
    let medal = '‚Äî';
    if(accuracy === 1 && seconds <= (total * 2.5)) medal = 'ü•á –ó–æ–ª–æ—Ç–æ';
    else if(accuracy >= 0.9 && seconds <= (total * 4)) medal = 'ü•à –°–µ—Ä–µ–±—Ä–æ';
    else if(accuracy >= 0.7) medal = 'ü•â –ë—Ä–æ–Ω–∑–∞';
    else medal = '‚Äî';
    medalEl.textContent = medal;
    // final message
    finalMsg.className = 'feedback ' + (correct === total ? 'ok' : 'bad');
    finalMsg.textContent = `–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö ${correct}/${total}. –ë–∞–ª–ª—ã ${score}. ${medal !== '‚Äî' ? '–ù–∞–≥—Ä–∞–¥–∞: ' + medal : ''}`;
    // stop timer if running
    stopTimer();
    return {correct, total, score, medal};
  }

  function finishRun(){
    // auto-check when time expires
    checkAll();
  }

  // reveal toggle: autofil indices only when empty or incorrect; store originals to restore on hide
  function toggleReveal(){
    reveal = !reveal;
    revealBtn.textContent = reveal ? '–°–∫—Ä—ã—Ç—å' : '–ü–æ–∫–∞–∑–∞—Ç—å';
    if(reveal){
      // reveal: fill answers where empty or wrong
      autoRevealed.clear();
      originalValues = {};
      grid.forEach((g, idx)=>{
        const valRaw = g.inputEl.value.trim();
        const val = valRaw === '' ? NaN : parseInt(valRaw,10);
        const ok = (!Number.isNaN(val)) && (val === g.ans);
        if(!ok){
          // store original
          originalValues[idx] = g.inputEl.value;
          g.inputEl.value = String(g.ans);
          g.inputEl.classList.add('revealed');
          autoRevealed.add(idx);
        }
      });
    } else {
      // hide: restore original user values for auto-filled indices
      autoRevealed.forEach(idx => {
        const g = grid[idx];
        if(!g) return;
        const orig = originalValues.hasOwnProperty(idx) ? originalValues[idx] : '';
        g.inputEl.value = orig;
        g.inputEl.classList.remove('revealed');
      });
      autoRevealed.clear();
      originalValues = {};
    }
  }

  // Start / Reset
  startBtn.addEventListener('click', ()=>{
    buildGrid();
    startTimer();
  });
  resetBtn.addEventListener('click', ()=>{ resetAll(); });
  checkBtn.addEventListener('click', ()=>{ checkAndStore(); });
  revealBtn.addEventListener('click', ()=>{ toggleReveal(); });

  // regenerate on option change but keep minimal changes: only rebuild grid
  levelEl.addEventListener('change', ()=>{ if(!running) buildGrid(); });
  sizeEl.addEventListener('change', ()=>{ if(!running) buildGrid(); });
  timedEl.addEventListener('change', ()=>{ /* no rebuild required */ });

  // initial build
  buildGrid();

  // Save best in localStorage: when a run finishes successfully (all correct), store best score
  function storeBest(res){
    try{
      if(!res) return;
      const key = 'tables_best';
      const prev = parseInt(localStorage.getItem(key)||'0',10) || 0;
      if(res.score > prev){
        localStorage.setItem(key, String(res.score));
      }
      // store last run summary
      localStorage.setItem('tables_last', JSON.stringify(res));
    } catch(e){ console.error(e); }
  }

  // Wrap checkAll to store best
  const origCheckAll = checkAll;
  window.checkAndStore = function(){
    const res = origCheckAll();
    storeBest(res);
    return res;
  };

})();
</script>
</body>
</html>
